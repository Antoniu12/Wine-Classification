# -*- coding: utf-8 -*-
"""Testare.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rlpiEl1EnPwUihb9Eh7eCRrXtrToOA3-

# Importuri
"""

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder

"""# Incarcarea datasetului pentru testare"""

def load_test_set_from_csv(filename='test_set.csv'):
    df = pd.read_csv(filename)
    X_test = df.drop(columns=['Label']).values
    y_test = df['Label'].values
    return X_test, y_test

X_test_np, y_test_np = load_test_set_from_csv()

"""## Transformarea in tensori"""

X_test_tensor = torch.tensor(X_test_np, dtype=torch.float32)
y_test_tensor = torch.tensor(y_test_np, dtype=torch.long)

test_dataset = TensorDataset(X_test_tensor, y_test_tensor)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

"""# Redefinirea modelului MLP

"""

class MLPModel(nn.Module):
    def __init__(self, input_dim, output_dim):
        super(MLPModel, self).__init__()
        self.layer1 = nn.Linear(input_dim, 128)
        self.layer2 = nn.Linear(128, 64)
        self.output = nn.Linear(64, output_dim)

    def forward(self, x):
        x = torch.relu(self.layer1(x))
        x = torch.relu(self.layer2(x))
        x = self.output(x)
        return x

"""## Incarcarea datelor din model"""

input_dim = X_test_tensor.shape[1]
output_dim = len(np.unique(y_test_tensor.numpy()))
model2 = MLPModel(input_dim, output_dim)
model2.load_state_dict(torch.load('mlp_model.pth'))
model2.eval()

"""# Testarea modelului"""

def evaluate_model(model, test_loader, le):
    model.eval()
    y_true = []
    y_pred = []
    with torch.no_grad():
        for X_batch, y_batch in test_loader:
            outputs = model(X_batch)
            _, predicted = torch.max(outputs.data, 1)
            y_pred.extend(predicted.tolist())
            y_true.extend(y_batch.tolist())
    target_names = [str(cls) for cls in le.classes_]
    print(classification_report(y_true, y_pred, target_names=target_names, zero_division=0))
    cm = confusion_matrix(y_true, y_pred)
    sns.heatmap(cm, annot=True, fmt="d", cmap='Blues', xticklabels=target_names, yticklabels=target_names)
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.title('Confusion Matrix for MLPModel')
    plt.show()

le = LabelEncoder()
y_encoded = np.array([0, 1, 2])
le.fit(y_encoded)

evaluate_model(model2, test_loader, le)